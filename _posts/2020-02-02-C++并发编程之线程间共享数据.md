---
layout: post
title: 
categories: [C++]
description: 
keywords: C++
---

# 线程间共享数据存在的问题
如果多个线程只读数据的话，是没有问题的，问题是多个线程同时读写数据导致的
## 数据竞争
数据竞争一般指单个对象呗并发修改而产生的竞争条件，造成的后果是未定义的。
## 避免数据竞争
* 使用互斥量保护共享数据
* 无锁编程  

# 用互斥量保护数据
## 互斥量
互斥量是最常见的数据保护机制，C++提供了两种互斥量：std::mutex和std::recursive_mutex。
### mutex
mutex是最常见的互斥量，调用成员函数`lock()`来锁定，调用`unlock()`来解锁，但是一般都是搭配锁一起使用
### std::recursive_mutex
recursive_mutex是递归互斥量，一个线程试图锁定已经持有的mutex将导致未定义的行为，但是递归锁允许单个线程多次获取锁，只是解锁次数要与上锁次数保持一致
## 使用锁
标准库提供了三种锁std::lock、std::lock_guard和std::unique_lock。
### lock_guard
lock_guard 使用了RAII技术，锁会自动释放，无需手动释放锁，只是要注意缩小锁的范围
```
    std::mutex mtx;
    std::lock_guard<std::mutex> guard(mtx);
```
### unique_lock
相比于lock_guard,unique_lock更加灵活，在其析构时，mutex仍被锁住，其会自动调用unlock(),如果没被锁住，则析构函数不做任何事情
### lock
为了避免死锁，常见的做法是按相同的顺序对多个互斥量就行加锁，lock可以同时锁住多个互斥量，而没有死锁的风险
```
    std::mutex mtx1;
    std::mutex mtx2;
    std::lock(mtx1, mtx2);
```
## 死锁
死锁是多线程编程中最常见的问题，典型的死锁场景是两个线程都持有一个锁并去获取对方已经持有的锁。但有时候死锁并不是那么的直观，比如一个线程安全的类，没有接口都会先上锁，再调用其他函数，如果调用的还是同个对象的接口，也会造成死锁
## 避免死锁
避免死锁的准则：
1. 避免嵌套锁
单个线程如果已经获取到锁了，在没有释放的时候，不再去获取其他锁，单个线程只持有一个锁是不会导致死锁的，如果需要获取多个锁，使用std::lock()。
2. 在持有锁时，避免调用其他用户的代码
代码里调用第三方库是一件很常见的事情，但是由于内部不透明，在加锁调用接口的时候，会存在死锁的风险
3. 以固定顺序加锁和解锁
多个线程都按相同的顺序进行加锁与解锁，不会造成交叉获取锁的情况，避免死锁。
